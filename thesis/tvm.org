################################################################################
#+TITLE: ThesisVM BEng
#+AUTHOR: Kajetan Rzepecki
#+DATE: 2013
#
#+BEGIN_OPTIONS
#+BIND: org-export-latex-title-command ""
#+STARTUP: content
#+LaTeX_CLASS: aghdpl
#+LaTeX_CLASS_OPTIONS: [a4paper, 12pt]
#+LaTeX_HEADER: \usepackage[polish]{babel}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage[nottoc, notlof, notlot]{tocbibind}
#+OPTIONS: tags:nil, todo:nil, toc:nil, date:nil
#+END_OPTIONS
####################

# Helpers & Stuff
#+begin_src emacs-lisp :exports none
  (add-to-list 'org-export-latex-classes
               '("aghdpl"
                 "\\documentclass{aghdpl}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                 ))
  (setq org-export-latex-classes (cdr org-export-latex-classes))
#+end_src

# AGH setup:
#+BEGIN_OPTIONS
#+LATEX_HEADER: \shortauthor{K. Rzepecki}
#+LATEX_HEADER: \degreeprogramme{Informatyka}

#+LATEX_HEADER: \thesistype{Praca dyplomowa inżynierska}

#+LATEX_HEADER: \titlePL{Implementacja maszyny wirtualnej dla funkcyjnych języków programowania wspierających przetwarzanie współbieżne.}
#+LATEX_HEADER: \titleEN{Implementation of a virtual machine for functional programming languages with support for concurrent computing.}

#+LATEX_HEADER: \shorttitlePL{Implementacja maszyny wirtualnej dla funkcyjnych języków programowania \dots}
#+LATEX_HEADER: \shorttitleEN{Implementation of a virtual machine for functional programming languages \dots}

#+LATEX_HEADER: \supervisor{dr inż. Piotr Matyasik}

#+LATEX_HEADER: \department{Katedra Informatyki Stosowanej}

#+LATEX_HEADER: \faculty{Wydział Elektrotechniki, Automatyki,\protect\\[-1mm] Informatyki i Inżynierii Biomedycznej}

#+LATEX_HEADER: \acknowledgements{Serdecznie dziękuję opiekunowi pracy za wsparcie merytoryczne oraz dobre rady edytorskie pomocne w tworzeniu pracy.}
#+END_OPTIONS

# Title pages & table of contents:
#+begin_latex
\titlepages
\tableofcontents
#+end_latex

# List of Listings specific:
#+begin_latex
\newcommand{\listlistingname}{\bfseries\Large{Spis listingów}}
\newlistof[chapter]{mylisting}{mlol}{\listlistingname}
\newcommand{\mylisting}[1]{%
  \refstepcounter{mylisting}%
  #1%
  \addcontentsline{mlol}{figure}
    {\protect\numberline{\thechapter.\thelisting}#1}\par%
}
\renewcommand{\cftbeforemloltitleskip}{20mm}
\renewcommand{\cftaftermloltitleskip}{5mm}
#+end_latex

* Wstęp
- Opisać temat pracy.
- Opisać czym jest maszyna wirtualna.

#+begin_center
#+label: ref:vm-arch
#+caption: Schemat interakcji z Maszyną Wirtualną.
#+attr_latex: scale=0.7
[[file:./img/fullarch.pdf]]
#+end_center

- Opisać czym jest przetwarzanie współbierzne w kontekście pracy.
- Wspomnieć o Modelu Aktorowym. [[cite:Hewitt1973,Clinger1981]].
- Krótko opisać cel pracy - implementacja interpretera kodu bajtowego, GC i SMP.
- Wspomnieć o języku implementacji - język D. [[cite:Alexandrescu2010]]

** Motywacja pracy
- Sformułować problem do rozwiązania.
- Opisać krótko kod Erlanga prezentujący problem.

#+latex: \begin{listing}[ht]
#+latex: \caption{\mylisting{Fragment kodu prezentujący problem występujący w języku Erlang.}}
#+latex: \label{erlang-problem}
#+bind: org-export-latex-minted-options (("frame" "single"))
#+begin_src erlang
start() ->
    Data = file:read("file.json"),    %% <<"Dane ...">>
    transmogrify(Data).

transmogrify(Data) ->
    Pids = framework:spawn_bajilion_procs(fun do_stuff/1),
    JSON = json:decode(Data),         %% {[Dane ...]}
    framework:map_reduce(Pids, JSON). %% $#&^@

do_stuff(JSON) ->
    %% Operacje na danych.
    result.
#+end_src
#+bind: org-export-latex-minted-options ()
#+latex: \end{listing}

- Opisać konieczność kopiowania wiadomości w architekturze prywatnej sterty.

#+latex: \begin{listing}[ht]
#+latex: \caption{\mylisting{Suboptymalne rozwiązanie problemu w języku Erlang.}}
#+latex: \label{erlang-solution}
#+bind: org-export-latex-minted-options (("frame" "lines"))
#+begin_src erlang
transmogrify(Data) ->
    Pids = framework:spawn_bajilion_procs(fun do_stuff/1),
    framework:map_reduce(Pids, Data).

do_stuff(Data) ->             %% <<"Dane ...">>
    JSON = json:decode(Data), %% {[Dane ...]} * bazylion
    %% Operacje na danych.
    result.
#+end_src
#+bind: org-export-latex-minted-options ()
#+latex: \end{listing}

- Opisać sposób Erlanga na rozważany problem.
- Opisać problemy publicznej sterty (związane z GC).
- Opisać sposób w jaki ThesisVM ma je rozwiązać.

** Zawartość pracy
- Opisać zakres pracy.
- Opisać zawartość [[Architektura ThesisVW]].
- Opisać zawartość [[Interpreter kodu bajtowego]].
- Opisać zawartość [[Model zarządzania pamięcią]].
- Opisać zawartość [[Model przetwarzania współbieżnego]].
- Opisać zawartość [[Podsumowanie]].
- Opisać zawartość [[Przykładowe programy]].
- Opisać zawartość [[Wizualizacja stanu maszyny]].
- Opisać zawartość [[Spisy wbudowanych funkcji i operatorów]].

* Architektura ThesisVM
- Opisać architekturę w odniesieniu do wyżej wymienionych celów pracy.

#+begin_center
#+label: ref:tvm-arch
#+caption: Architektura maszyny wirtualnej ThesisVM.
#+attr_latex: scale=1.0
[[file:./img/arch.pdf]]
#+end_center

- Wspomnieć o wykorzystaniu TVMIR.
- Wspomnieć o wykorzystaniu kodu bajtowego i jego kompilatora.

** Reprezentacja pośrednia programów (TVMIR)
- Opisać krótko TVMIR. [[cite:Abelson1996,PeytonJones1992]]
- Opisać dostępne typy danych.
- Opisać dostępne konstrukcje języka.
- Porównać TVMIR do core lang. [[cite:PeytonJones1992]]
- Porównać TVMIR do Core Erlang. [[cite:Carlsson2001,Carlsson2004]]

** Kompilacja kodu bajtowego

#+begin_center
#+label: ref:tvm-compiler-pipeline
#+caption: /Pipeline/ kompilatora kodu bajtowego ThesisVM wraz ze schematami reprezentacji danych poszczególnych faz.
#+attr_latex: scale=0.55
[[file:./img/pipeline.pdf]]
#+end_center

- Opisać krótko analizę leksykalną.
- Opisać krótko analizę syntaktyczną.
- Opisać krótko analizę semantyczną (+ proste transformacje TVMIR jeśli jakieś będą).
- Opisać krótko fazę optymalizacji (+ proste optymalizacje jak constant folding, etc).
- Opisać krótko generację kodu bajtowego.

** Interpretacja kodu bajtowego
- Opisać ogólnie architektury pamięci i przekazywanie wiadomości. [[cite:Wilhelmsson2005]]
- Opisać sposób budowy interpreterów kodu bajtowego. [[cite:Steele1978]]
- Opisać krótko różne architektury interpreterów (stosowa, rejestrowa, grafowa). [[cite:PeytonJones1992]]
- Wspomnieć o wybranym modelu.

** Zarządzanie pamięcią
- Opisać krótko strategie alokacji i architektury sterty. [[cite:Wilson1995,Wilhelmsson2005]]

#+begin_center
#+label: ref:mem-archs
#+caption: Różne modele wykorzystania pamięci maszyn wirtualnych.
#+attr_latex: scale=1.0
[[file:./img/mem.pdf]]
#+end_center

- Opisać krótko strategie GC (ref-count vs tracing). [[cite:Bacon2004]]
- Wspomnieć o problemach kolekcji tracing GC (w kontekście problemu Erlanga). [[cite:Gudeman1993]]
- Umotywować wykorzystanie zliczania referencji (wspomnieć, że Erlang też korzysta). [[cite:Shahriyar2012]]

** Przetwarzanie współbieżne
- Opisać różne sposoby przetwarzania wielowątkowego - SMP i AMP.
- Opisać wady i zalety poszczególnych modeli (SMP - skalowalność, AMP - VCGC). [[cite:Huelsbergen1998]]
- Opisać krótko Model Aktorowy. [[cite:Hewitt1973,Clinger1981]].
- Umotywować wybrany model przetwarzania i jego relację z Modelem Actorowym.

* Interpreter kodu bajtowego

- Opisać wybrany model Three Instruction Machine. [[cite:Fairbairn1987,PeytonJones1992]], [[cite:Kaser1992]]
- Opisać krótko działanie TIM, zwrócić uwagę na leniwość. [[cite:Fairbairn1987,PeytonJones1992]], [[cite:Kaser1992]]
- Opisać modyfikacje modelu TIM.

#+begin_center
#+label: ref:tvm-regs
#+caption: Schemat stanu maszyny wirtualnej.
#+attr_latex: scale=1.5
[[file:./img/uProc2.pdf]]
#+end_center

- Opisać wykorzystywane rejestry.
- Opisać krótko alternatywne rozwiązania (SECD, TRSECD, SICP machine). [[cite:VanHorn2010,Ramsdell1999,Abelson1996,Steele1978]], [[cite:Kaser1992]]

** Implementacja obietków prostych
- Opisać implementację atomów ($\leq$ 8 bajtów).
- Opisać metodę tagowania atomów (dolne trzy bity) [[cite:Gudeman1993]], [[cite:Cook2013]]
- Opisąć optymalizacje/trejdofy wybranego sposobu tagowania. [[cite:Gudeman1993]], [[cite:Cook2013]]

** Implementacja obiektów złożonych
- Opisać implementację obiektów złożonych ($\geq$ 8 bajtów - pary, funkcje/domknięcia, procesy).
- Opisać metodę tagowania (dolne dwa bajty + górne 48 bitów zarezerwowane dla GC). [[cite:Gudeman1993]], [[cite:Cook2013]]
- Opisać komponenty par.
- Opisać poszczególne komponenty obiektów funkcyjnych.
- Opisać reprezentację obiektów procesów (gołe rejestry).
- Opisać relację pomiędzy zbiorem rejestrów a reprezentacją procesu.

** Implementacja wbudowanych operatorów
- Opisać wykorzystanie VStack.
- Opisać dostępne operacje prymitywne (LispKit). [[cite:Abelson1996]]
- Skonfrontować dostępne operacje prymitywne z Core Erlang. [[cite:Carlsson2004]]
- Opisać optymalizacje operacji arytmetycznych. [[cite:Gudeman1993]]

** Ewaluacja argumentów i aplikacja funkcji
- Opisać działanie interpretera kodu bajtowego ThesisVM. [[cite:Fairbairn1987,PeytonJones1992]]
- Opisać leniwą ewaluację argumentów.
- Opisać aplikację funkcji.
- Opisać aplikację operacji prymitywnych.

** Reprezentacja kodu bajtowego ThesisVM
- Opisać reprezentację kodu bajtowego (listy opkodów).
- Opisać optymalizacje TVMBC (wykorzystanie górnych dwóch bajtów słowa, 0 = pushc, threading, itd).
- Opisać dostępne opkody kodu bajtowego. [[cite:Fairbairn1987,PeytonJones1992]]

** Generacja kodu bajtowego ThesisVM
- Opisać szczegółowo generację kodu bajtowego. [[cite:PeytonJones1992]]

* Model zarządzania pamięcią
- Opisać krótko architekturę wspólnej sterty. [[cite:Wilhelmsson2005]]

# TODO Actually make this.
#+begin_center
#+label: ref:tvm-shared-mem
#+caption: Model wspólnej pamięci ThesisVM.
#+attr_latex: scale=1.0
[[file:./img/sharedmem.pdf]]
#+end_center

- Opisać strategie zarządzania pamięcią (alokator i GC). [[cite:Bacon2004]]

** Architektura wspólnej sterty
- Opisać szczegółowo wybraną architekturę.
- Wspomnieć o problemach wybranej architektury (duży root-set, długie kolekcje). [[cite:Wilhelmsson2005]]
- Skonfrontować publiczną stertę z architekturą prywatnej sterty. [[cite:Wilhelmsson2005]]
- Wspomnieć o problemach prywatnej sterty (powolne przekazywanie wiadomości przez kopiowanie). cite:Wilhelmsson2005
- Wspomnieć o istnieniu rozwiązań hybrydowych. [[cite:Wilhelmsson2005]]
- Wspomnięć o problemach rozwiązań hybrydowych (usunięte z Erlang/OTP R15B02).

** Implementacja alokatora obiektów
- Opisać działanie kaskadowego alokatora. [[cite:Wilson1995]]

# TODO Actually make this.
#+begin_center
#+label: ref:tvm-alloc
#+caption: Schemat kaskadowych alokatorów.
#+attr_latex: scale=1.0
[[file:./img/allocator.pdf]]
#+end_center

- Opisać implementację wykorzystanego alokatora.
- Opisać optymalizacje alokatora (wykorzystanie free listy).
- Opisać zmiany wprowadzone w stanie maszyny wirtualnej (dodatkowe rejestry).
- Opisać krótko alternatywne rozwiązania (mallocator, etc). [[cite:Wilson1995]]

** Kolekcja nieosiągalnych obiektów
- Opisać leniwe zliczanie referencji. [[cite:Boehm2004]]

# TODO Actually make this.
#+begin_center
#+label: ref:tvm-lazy-refcount
#+caption: Schemat działania algorytmu leniwego zliczania referencji.
#+attr_latex: scale=0.8
[[file:./img/lazyrefcount.pdf]]
#+end_center

- Opisać implementację algorytmu leniwego zliczania referencji. [[cite:Bacon2004]]
- Opisać konieczność wykorzystania operacji atomowych i barier pamięci (liczniki referencji).

#+begin_center
#+label: ref:tvm-gc-regs
#+caption: Schemat rejestrów wymaganych przez implementację kolektora obiektów nieosiągalnych.
#+attr_latex: scale=1.5
[[file:./img/GC2.pdf]]
#+end_center

- Opisać zmiany wprowadzone w stanie maszyny wirtualnej (dodatkowe rejestry).
- Opisać narzut pamięci związany z licznikiem referencji i leniwością algorytmu. cite:Boehm2004,Bacon2004
- Opisać krótko wady, możliwe usprawnienia i alternatywne rozwiązania (zaproponowane przez Joe'go oraz VCGC) [[cite:Armstrong1995,Huelsbergen1998]]

** Kolekcja obiektów cyklicznych
- Opisać, że obiekty cykliczne nie występują.
- Wspomnieć o możliwości zaimplementowania zapasowego stop-the-world GC.
- Wspomnieć o możliwości cyklicznego uruchamiania D'owego GC.

* Model przetwarzania współbieżnego
- Opisać bardziej szczegółowo Model Aktorowy i asynchroniczne przekazywanie wiadomości. [[cite:Hewitt1973,Clinger1981]]

# TODO Actually make this.
#+begin_center
#+label: ref:tvm-smp
#+caption: Schemat symetrycznego multiprocesora ThesisVM.
#+attr_latex: scale=1.0
[[file:./img/SMP2.pdf]]
#+end_center

- Opisać bardziej szczegółowo działanie SMP - wiadomości kontrolne oraz RQue.

** Implementacja Modelu Aktorowego
- Opisać powstawanie procesów i prymityw =spawn=.
- Opisać logiczną autonomiczność procesów (brak mutacji = inne procesy nie mogą ingerować).
- Opisać sposób porozumiewania się procesów (kolejki nieblokujące). [[cite:MichaelScott1996,Herlihy2002]]
- Opisać implementację kolejek nieblokujących (+ weryfikacja poprawności). [[cite:MichaelScott1996,]]Groves2008- Opisać wykorzystanie CAS i problem ABA.

#+begin_center
#+label: ref:tvm-actor-regs
#+caption: Schemat rejestrów wymaganych przez implementację Modelu Aktorowego.
#+attr_latex: scale=1.5
[[file:./img/Actor2.pdf]]
#+end_center

- Opisać zmiany wprowadzone w stanie maszyny wirtualnej (dodatkowe rejestry).
- Opisać krótko wady i możliwe usprawnienia zastosowanego rozwiązania (dynamic size, wait-free, optimistic FIFO). [[cite:Herlihy2002,Kogan2011,Ladan-Mozes2004]]
- Opisać krótko alternatywne podejścia (synchroniczne przekazywanie wiadomości - kanały, locki/mutexy/semafory).

** Implementacja przesyłania wiadomości
- Opisać implementację prymitywów =send= oraz =receive=.
- Zwrócić uwagę na konieczność wykorzystania operacji atomowych oraz barier pamięci.
- Snippet kodu przesyłającego wiadomość.

# TODO Actually make this.
#+begin_center
#+label: ref:tvm-lazy-refcount
#+caption: Schemat działania przesyłania wiadomości.
#+attr_latex: scale=0.8
[[file:./img/messagepassing.pdf]]
#+end_center

- Opisać co dzieje się podczas wysyłania wiadomości.
- Opisać sposób pobierania wiadomości z kolejki.
- Zwrócić uwagę na fakt, że problem kopiowania został zniwelowany kosztem lekkich barier pamięci.

** Harmonogramowanie procesów
- Opisać sposób harmonogramowania procesów (brak load-balancingu, losowy spawn).
- Opisać implementację prymitywu =sleep= oraz sleep-table.
- Opisać wiadomości kontrolne.

# TODO Move this to an earlier section?
#+begin_center
#+label: ref:tvm-scheduler-regs
#+caption: Schemat rejestrów wymaganych przez usprawnienia hanmonogramowania SMP.
#+attr_latex: scale=1.5
[[file:./img/Scheduler2.pdf]]
#+end_center

- Opisać możliwe usprawnienia (load-balancing i dzielenie zużycia).

* Podsumowanie
- Opisać co udało się zrobić.
- Opisać czego nie udało się zrobić (+ możliwe usprawnienia).
- Opisać plany na przyszły rozwój projektu (priorytet procesów, load balancing SMP, wsparcie dla Core Erlang, bytecode threading, przebiegi optymalizacyjne podczas kompilacji, umożliwienie dystrybucji na wiele maszyn, zapasowy kolektor śmieci cyklicznych, opcja wykorzystania sterty prywatnej i autonomicznego alokatora, natywna kompilacja JIT, wektory, data-level parallelism, optymalizacja wykorzystania stosu, hardłerowa implementacja interpretera kodu bajtowego).

** Leniwe zliczanie referencji
- Przeanalizować szybkość, pauzy, zużycie pamięci.

** Przesyłanie wiadomości
- Przeanalizować szybkość przesyłania wiadomości/konieczność czekania procesów, wielkość kolejek wiadomości.


# The bibliography
#+begin_latex
\bibliographystyle{ieeetr}
\bibliography{bibs}
#+end_latex

#+latex: \appendix
* Przykładowe programy
- Opisać sposób uruchamiania maszyny wirtualnej.
- Hello world.
- Factorial.
- Fibonacci.
- Concurrent Hello world.
- Map-reduce.

* Wizualizacja stanu maszyny wirtualnej
- Opisać narzędzie do rysowania grafów stanu maszyny i dać kilka przykładów.

* Spisy wbudowanych funkcji i operatorów
#+begin_latex
{\Large\noindent\textbf{Spis funkcji wbudowanych}}
#+end_latex

- Wylistować funkcje wbudowane.

#+begin_latex
\vspace{2cm}
{\Large\noindent\textbf{Spis operatorów wbudowanych}}
#+end_latex

- Wylistować operacje prymitywne.

* Spisy rysunków, fragmentów kodu i tablic
#+begin_latex
\begingroup
  \renewcommand*{\addvspace}[1]{}
  \listoffigures
  \listofmylisting
  \listoftables
\endgroup
#+end_latex

